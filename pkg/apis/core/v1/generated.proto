/*
Copyright 2022 The fornax-serverless Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package centaurusinfra.io.fornax_serverless.pkg.apis.core.v1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "centaurusinfra.io.fornax-serverless.pkg.apis.core.v1";

message AccessEndPoint {
  // TCP/UDP
  optional string protocol = 1;

  // IPaddress
  optional string ipAddress = 2;

  // Port
  optional int32 port = 3;
}

// Application
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Application {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ApplicationSpec spec = 2;

  optional ApplicationStatus status = 3;
}

// ApplicationList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message ApplicationList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Application items = 2;
}

// ApplicationSession
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message ApplicationSession {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ApplicationSessionSpec spec = 2;

  optional ApplicationSessionStatus status = 3;
}

// ApplicationSessionList
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message ApplicationSessionList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ApplicationSession items = 2;
}

// ApplicationSessionSpec defines the desired state of ApplicationSession
message ApplicationSessionSpec {
  // ApplicationName, client provided application
  optional string applicationName = 1;

  // Session data is a base64 string pass through into application instances when session started
  // +optional
  optional string sessionData = 2;

  // if a application instance evacuated all session, kill it, default true
  optional bool killInstanceWhenSessionClosed = 3;

  // how long to wait for before close session, default 60
  optional uint32 closeGracePeriodSeconds = 4;

  // how long to wait for session status from Starting to Available
  optional uint32 openTimeoutSeconds = 5;
}

// ApplicationSessionStatus defines the observed state of ApplicationSession
message ApplicationSessionStatus {
  // Endpoint this session is using
  // +optional
  // +listType=atomic
  repeated AccessEndPoint accessEndPoints = 1;

  // Session status, is Starting, Available or Closed.
  // +optional
  optional string sessionStatus = 2;

  // +optional
  // +listType=set
  repeated k8s.io.api.core.v1.LocalObjectReference clientSessions = 3;

  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time availableTime = 4;

  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time closeTime = 5;

  // +optional, for metrics test
  optional int64 availableTimeMicro = 6;
}

// ApplicationSpec defines the desired state of Application
message ApplicationSpec {
  // runtime image and resource requirement of a application container
  // +listType=atomic
  repeated k8s.io.api.core.v1.Container containers = 1;

  // container will use grpc session service on node agent to start application session
  optional bool usingNodeSessionService = 2;

  // Data contains the configuration data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // Values with non-UTF-8 base64 string of byte sequences
  // +optional
  map<string, string> configData = 3;

  // application scaling policy
  optional ScalingPolicy scalingPolicy = 4;
}

// ApplicationStatus defines the observed state of Application
message ApplicationStatus {
  // Total number of non-terminated pods targeted
  optional int32 desiredInstances = 1;

  // Total number of available instances, including pod not scheduled yet
  // +optional
  optional int32 totalInstances = 2;

  // Total number of instances pending schedule and implement
  // +optional
  optional int32 pendingInstances = 3;

  // Total number of instances pending delete and cleanup
  // +optional
  optional int32 deletingInstances = 4;

  // Total number of instances which have been started by node
  // +optional
  optional int32 allocatedInstances = 5;

  // Total number of pods which do not have session on it
  // +optional
  optional int32 idleInstances = 6;

  // The latest deploy history of this app.
  optional DeploymentHistory latestHistory = 7;

  // Represents the latest available observations of a deployment's current state.
  // +optional
  // +patchMergeKey=updateTime
  // +patchStrategy=merge
  // +listType=set
  repeated DeploymentHistory history = 8;
}

message DeploymentHistory {
  // Type of deployment condition.
  optional string action = 1;

  // The last time this deployment was updated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updateTime = 2;

  // The reason for the last transition.
  optional string reason = 3;

  // A human readable message indicating details about the transition.
  optional string message = 4;

  optional string deploymentStatus = 5;
}

// high watermark should > low watermark, if both are 0, then no auto scaling for idle buffer,
// application instance are created on demand when there is no instance to hold a comming session
message IdelSessionNumThreshold {
  // scaling down when idle session more than this number
  // +optional, default 0
  optional uint32 high = 1;

  // scaling up when idle session less than this number
  // +optional, default 0
  optional uint32 low = 2;
}

// high watermark should > low watermark, if both are 0, then no auto scaling for idle buffer,
// application instance are created on demand when there is no instance to hold a comming session
message IdelSessionPercentThreshold {
  // scaling down when idle session percent more than this number
  // +optional, default 0, must less than 100
  optional uint32 high = 1;

  // scaling up when idle session percent less than this number
  // +optional, default 0, must less than 100
  optional uint32 low = 2;
}

message ScalingPolicy {
  optional uint32 minimumInstance = 1;

  optional uint32 maximumInstance = 2;

  optional uint32 burst = 3;

  // what session scaling policy to use, absolute num or percent
  optional string scalingPolicyType = 4;

  // +optional, must set if ScalingPolicyType == "idle_session_number"
  optional IdelSessionNumThreshold idleSessionNumThreshold = 5;

  // +optional, must set if ScalingPolicyType == "idle_session_percent"
  optional IdelSessionPercentThreshold idleSessionPercentThreshold = 6;
}

